# Пояснення  
> У цьому файлі описано програму на Rust, що реалізує два завдання:
> 1. Багатопотокове обчислення чисел Фібоначчі
> 2. Паралельна та послідовна обробка масиву для знаходження найчастішого числа

---

## 1. Обчислення чисел Фібоначчі — `fib(n: u32) -> Vec<u32>`

```rust
fn fib(n: u32) -> Vec<u32> {
    let mut sequence = Vec::new();

    if n == 0 {
        return sequence;
    }

    sequence.push(0);
    if n == 1 {
        return sequence;
    }

    sequence.push(1);
    sequence.push(1);

    for _ in 1..n {
        let next = sequence[sequence.len() - 1] + sequence[sequence.len() - 2];
        sequence.push(next);
    }

    sequence
}
```

> Функція повертає вектор чисел Фібоначчі довжиною `n`.  
> Початково додаються значення `0`, `1`, `1`, а потім кожен наступний елемент обчислюється як сума двох попередніх.  
> Цикл починається з 1 до `n`, що може викликати надмірне обчислення для малих значень `n`.

---

## 2. Завдання 1 — `task1()`

```rust
fn task1() {
    let handles: Vec<_> = (0..5).map(|i| {
        thread::spawn(move || {
            ...
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

> Створюється 5 потоків (паралельних задач) за допомогою `thread::spawn()`.  
> Кожен потік обчислює 5 чисел Фібоначчі (`n` від `i * 5` до `(i + 1) * 5`).  
> Після обчислення вимірюється час виконання кожного потоку окремо.  
> Використовується `join()` для очікування завершення всіх потоків.

---

## 3. Послідовна обробка масиву — `sequential_processing(arr: &[i32]) -> i32`

```rust
fn sequential_processing(arr: &[i32]) -> i32 {
    let mut counts = [0; 301];
    for &num in arr {
        counts[(num + 200) as usize] += 1;
    }
    ...
    max_num
}
```

> Функція знаходить **найчастіше число** у масиві цілих чисел від `-200` до `100`.  
> Зміщення `+200` дозволяє використовувати масив `counts[0..300]` для збереження кількості входжень кожного значення.  
> У фіналі повертається число з найбільшою кількістю входжень.

---

## 4. Паралельна обробка масиву — `parallel_processing(arr: Arc<Vec<i32>>, m: usize) -> i32`

```rust
fn parallel_processing(arr: Arc<Vec<i32>>, m: usize) -> i32 {
    ...
}
```

> Мета — розділити масив на `m` частин і обробити їх паралельно.  
> Для передачі масиву між потоками використовується `Arc` (atomic reference count).  
> Кожен потік повертає власний масив підрахунків `counts`, після чого всі вони з'єднуються.  
> Фінальний етап — знаходження числа з максимальною частотою.

---

## 5. Завдання 2 — `task2()`

```rust
fn task2() {
    let mut rng = rand::thread_rng();
    let mut arr = vec![0; 100000];
    for i in 0..100000 {
        arr[i] = rng.gen_range(-200..=100);
    }
    ...
}
```

> Генерується масив з 100 000 випадкових чисел у діапазоні `[-200; 100]`.  
> Після цього:
> - проводиться послідовна обробка (`sequential_processing`)
> - потім паралельна обробка з `m = 2`, `4` та `8` потоками  
> Для кожного методу вимірюється час виконання.

---

## 6. Головна функція — `main()`

```rust
fn main() {
    println!("Завдання 1:");
    task1();
    println!("\nЗавдання 2:");
    task2();
}
```

> Виконується запуск обох завдань:
- Завдання 1: багатопотокове обчислення чисел Фібоначчі
- Завдання 2: аналіз великого масиву з вимірюванням ефективності послідовної та паралельної обробки
